<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AnnotatedMethodGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Orne Test Generators</a> &gt; <a href="index.source.html" class="el_package">dev.orne.test.rnd.generators</a> &gt; <span class="el_source">AnnotatedMethodGenerator.java</span></div><h1>AnnotatedMethodGenerator.java</h1><pre class="source lang-java linenums">package dev.orne.test.rnd.generators;

/*-
 * #%L
 * Orne Test Generators
 * %%
 * Copyright (C) 2022 Orne Developments
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Lesser Public License for more details.
 * 
 * You should have received a copy of the GNU General Lesser Public
 * License along with this program.  If not, see
 * &lt;http://www.gnu.org/licenses/lgpl-3.0.html&gt;.
 * #L%
 */

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.WeakHashMap;

import javax.validation.constraints.NotNull;

import org.apache.commons.lang3.Validate;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apiguardian.api.API;
import org.apiguardian.api.API.Status;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import dev.orne.test.rnd.Generator;
import dev.orne.test.rnd.GeneratorMethod;
import dev.orne.test.rnd.Generators;
import dev.orne.test.rnd.Priority;
import dev.orne.test.rnd.UnsupportedValueTypeException;
import dev.orne.test.rnd.params.ExecutableGenerator;

/**
 * Generator of beans annotated with {@code Currency}.
 * 
 * @author &lt;a href=&quot;mailto:wamphiry@orne.dev&quot;&gt;(w) Iker Hernaez&lt;/a&gt;
 * @version 1.0, 2022-12
 * @since 0.1
 */
@API(status=Status.EXPERIMENTAL, since=&quot;0.1&quot;)
@Priority(Priority.ANNOTATION_GENERATORS)
public class AnnotatedMethodGenerator
implements Generator {

    /** The class logger. */
<span class="fc" id="L59">    private static final Logger LOG = LoggerFactory.getLogger(AnnotatedMethodGenerator.class);</span>

    /** Required modifiers for instance generation constructors. */
    private static final int GENERATOR_CONSTRUCTOR_MODIFIERS =
            Modifier.PUBLIC;
    /** Required modifiers for instance generation methods. */
    private static final int GENERATOR_METHOD_MODIFIERS =
            Modifier.STATIC | Modifier.PUBLIC;
    /** Informational message for misconfigured identity types. */
    private static final String HELP_MISCONFIGURED =
            &quot;Class '{}' generation is misconfigured.&quot;
            + &quot; See GeneratorMethod javadoc for correct bean generation configuration.&quot;
            + &quot; No further generation attempts will succed.&quot;;
    /** Error message for wrong generation constructor modifiers. */
    private static final String ERR_GENERATOR_CONSTRUCTOR_MODIFIERS =
            &quot;Invalid modifiers in annotated class generation constructor '{}' for type '{}'.&quot;
            + &quot; Method must be public.&quot;;
    /** Error message for wrong generation method modifiers. */
    private static final String ERR_GENERATOR_METHOD_MODIFIERS =
            &quot;Invalid modifiers in annotated class generation method '{}' for type '{}'.&quot;
            + &quot; Method must be public and static.&quot;;
    /** Error message for wrong generation method return type. */
    private static final String ERR_GENERATOR_METHOD_RETURN_TYPE =
            &quot;Invalid return type in annotated class generation method '{}' for type '{}'.&quot;
            + &quot; Method must return an instance of the class.&quot;;

    /** The cache of discovered annotated generators. */
<span class="fc" id="L86">    private final WeakHashMap&lt;Class&lt;?&gt;, Generator&gt; cache =</span>
            new WeakHashMap&lt;&gt;();

    /**
     * Creates a new instance.
     */
    public AnnotatedMethodGenerator() {
<span class="fc" id="L93">        super();</span>
<span class="fc" id="L94">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean supports(
            final @NotNull Class&lt;?&gt; type) {
<span class="fc bfc" id="L102" title="All 2 branches covered.">        return getAnnotatedGenerator(type) != null;</span>
    }

    /**
     * Verifies that the specified type is supported by this instance.
     * If test fails throws an {@code IllegalArgumentException} exception
     * as documented in {@link #defaultValue(Class)},
     * {@link #nullableDefaultValue(Class)}, {@link #randomValue(Class)} and
     * {@link #nullableRandomValue(Class)}.
     * 
     * @param type The requested value type.
     * @throws UnsupportedValueTypeException If the specified type is not supported.
     */
    protected void assertSupported(
            final @NotNull Class&lt;?&gt; type) {
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">        if (!supports(type)) {</span>
<span class="nc" id="L118">            throw new UnsupportedValueTypeException(String.format(</span>
                    &quot;Generators of type %s does not support generation of values of type %s&quot;,
<span class="nc" id="L120">                    getClass(),</span>
                    type));
        }
<span class="fc" id="L123">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public &lt;T&gt; @NotNull T defaultValue(
            final @NotNull Class&lt;T&gt; type) {
<span class="fc" id="L131">        assertSupported(type);</span>
<span class="fc" id="L132">        return getAnnotatedGenerator(type).defaultValue(type);</span>
    }

    @Override
    public &lt;T&gt; T nullableDefaultValue(
            final @NotNull Class&lt;T&gt; type) {
<span class="fc" id="L138">        assertSupported(type);</span>
<span class="fc" id="L139">        return getAnnotatedGenerator(type).nullableDefaultValue(type);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public &lt;T&gt; @NotNull T randomValue(
            final @NotNull Class&lt;T&gt; type) {
<span class="fc" id="L148">        assertSupported(type);</span>
<span class="fc" id="L149">        return getAnnotatedGenerator(type).randomValue(type);</span>
    }

    @Override
    public &lt;T&gt; T nullableRandomValue(
            final @NotNull Class&lt;T&gt; type) {
<span class="fc" id="L155">        assertSupported(type);</span>
<span class="fc" id="L156">        return getAnnotatedGenerator(type).nullableRandomValue(type);</span>
    }

    /**
     * Returns annotated generator to be used to create random instances of
     * the specified target class.
     * &lt;p&gt;
     * This method caches the generator (found or not) for further calls.
     * 
     * @param targetType The target class
     * @return The found annotated generator, or {@code null}
     */
    protected Generator getAnnotatedGenerator(
            final @NotNull Class&lt;?&gt; targetType) {
<span class="fc" id="L170">        Validate.notNull(targetType);</span>
        Generator generator;
<span class="fc" id="L172">        synchronized (this.cache) {</span>
<span class="fc" id="L173">            generator = this.cache.computeIfAbsent(targetType, this::discoverAnnotatedGenerator);</span>
<span class="fc" id="L174">        }</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (generator == Generators.MissingGenerator.INSTANCE) {</span>
<span class="fc" id="L176">            generator = null;</span>
        }
<span class="fc" id="L178">        return generator;</span>
    }

    /**
     * Clears the cache of discovered generators.
     */
    protected void clearCache() {
<span class="nc" id="L185">        synchronized (this.cache) {</span>
<span class="nc" id="L186">            this.cache.clear();</span>
<span class="nc" id="L187">        }</span>
<span class="nc" id="L188">    }</span>

    /**
     * Removes the cache of discovered generator for the specified class.
     * 
     * @param targetType The target class
     */
    protected void clearCache(
            final @NotNull Class&lt;?&gt; targetType) {
<span class="nc" id="L197">        synchronized (this.cache) {</span>
<span class="nc" id="L198">            this.cache.remove(targetType);</span>
<span class="nc" id="L199">        }</span>
<span class="nc" id="L200">    }</span>

    /**
     * Finds a constructor or static method annotated with
     * {@code GeneratorMethod} in the specified target class.
     * 
     * @param targetType The target class
     * @return The found annotated generator, or {@code null}
     */
    protected @NotNull Generator discoverAnnotatedGenerator(
            final @NotNull Class&lt;?&gt; targetType) {
<span class="fc" id="L211">        Generator generator = null;</span>
        try {
<span class="fc" id="L213">            generator = findDeclaredConstructor(targetType);</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">            if (generator == null) {</span>
<span class="fc" id="L215">                generator = findDeclaredMethod(targetType);</span>
            }
<span class="nc" id="L217">        } catch (final RuntimeException re) {</span>
<span class="nc" id="L218">            LOG.warn(HELP_MISCONFIGURED, targetType);</span>
<span class="fc" id="L219">        }</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (generator == null) {</span>
<span class="fc" id="L221">            generator = Generators.MissingGenerator.INSTANCE;</span>
        }
<span class="fc" id="L223">        return generator;</span>
    }

    /**
     * Finds a constructor annotated with {@code GeneratorMethod} in the
     * specified target class.
     * The method must be public and return an instance of the class.
     * 
     * @param &lt;T&gt; The target class
     * @param targetType The target class
     * @return The found annotated generator, or {@code null}
     */
    protected &lt;T&gt; ExecutableGenerator&lt;T&gt; findDeclaredConstructor(
            final @NotNull Class&lt;T&gt; targetType) {
<span class="fc" id="L237">        Validate.notNull(targetType);</span>
<span class="fc" id="L238">        ExecutableGenerator&lt;T&gt; generator = null;</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">        for (final Constructor&lt;?&gt; ctr : targetType.getDeclaredConstructors()) {</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">            if (ctr.isAnnotationPresent(GeneratorMethod.class)) {</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">                if ((ctr.getModifiers() &amp; GENERATOR_CONSTRUCTOR_MODIFIERS) != GENERATOR_CONSTRUCTOR_MODIFIERS) {</span>
<span class="nc" id="L242">                    LOG.warn(ERR_GENERATOR_CONSTRUCTOR_MODIFIERS,</span>
                            ctr,
                            targetType);
                } else {
                    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L247">                    final Constructor&lt;T&gt; tCtr = (Constructor&lt;T&gt;) ctr;</span>
<span class="fc" id="L248">                    generator = ExecutableGenerator.of(tCtr);</span>
                }
<span class="fc" id="L250">                break;</span>
            }
        }
<span class="fc" id="L253">        return generator;</span>
    }

    /**
     * Finds a method annotated with {@code GeneratorMethod} in the
     * specified target class.
     * The method must be public, static and return an instance of the class.
     * 
     * @param &lt;T&gt; The target class
     * @param targetType The target class
     * @return The found annotated generator, or {@code null}
     */
    protected &lt;T&gt; ExecutableGenerator&lt;T&gt; findDeclaredMethod(
            final @NotNull Class&lt;T&gt; targetType) {
<span class="fc" id="L267">        Validate.notNull(targetType);</span>
<span class="fc" id="L268">        ExecutableGenerator&lt;T&gt; generator = null;</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">        for (final Method method : targetType.getDeclaredMethods()) {</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">            if (method.isAnnotationPresent(GeneratorMethod.class)) {</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">                if ((method.getModifiers() &amp; GENERATOR_METHOD_MODIFIERS) != GENERATOR_METHOD_MODIFIERS) {</span>
<span class="nc" id="L272">                    LOG.warn(ERR_GENERATOR_METHOD_MODIFIERS,</span>
                            method,
                            targetType);
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">                } else if (!(targetType.isAssignableFrom(method.getReturnType()))) {</span>
<span class="nc" id="L276">                    LOG.warn(ERR_GENERATOR_METHOD_RETURN_TYPE,</span>
                            method,
                            targetType);
                } else {
<span class="fc" id="L280">                    generator = ExecutableGenerator.of(targetType, method);</span>
                }
<span class="fc" id="L282">                break;</span>
            }
        }
<span class="fc" id="L285">        return generator;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode() {
<span class="nc" id="L293">        return new HashCodeBuilder()</span>
<span class="nc" id="L294">                .append(getClass())</span>
<span class="nc" id="L295">                .build();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean equals(final Object obj) {
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (obj == null) { return false; }</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        if (obj == this) { return true; }</span>
        // Ignore cache
<span class="nc bnc" id="L306" title="All 2 branches missed.">        return obj.getClass() == getClass();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>