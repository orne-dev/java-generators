<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Generators.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Orne Test Generators</a> &gt; <a href="index.source.html" class="el_package">dev.orne.test.rnd</a> &gt; <span class="el_source">Generators.java</span></div><h1>Generators.java</h1><pre class="source lang-java linenums">package dev.orne.test.rnd;

/*-
 * #%L
 * Orne Test Generators
 * %%
 * Copyright (C) 2021 Orne Developments
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Lesser Public License for more details.
 * 
 * You should have received a copy of the GNU General Lesser Public
 * License along with this program.  If not, see
 * &lt;http://www.gnu.org/licenses/lgpl-3.0.html&gt;.
 * #L%
 */

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.ServiceLoader;
import java.util.WeakHashMap;

import javax.validation.constraints.NotNull;

import org.apache.commons.lang3.Validate;
import org.apiguardian.api.API;
import org.apiguardian.api.API.Status;

import dev.orne.test.rnd.params.ConstructorParameterTypeGenerator;
import dev.orne.test.rnd.params.GeneratorNotParameterizableException;
import dev.orne.test.rnd.params.MethodParameterTypeGenerator;
import dev.orne.test.rnd.params.MethodReturnTypeGenerator;
import dev.orne.test.rnd.params.ParameterTypeGenerator;
import dev.orne.test.rnd.params.ParameterizableGenerator;
import dev.orne.test.rnd.params.PropertyTypeGenerator;

/**
 * Main entry point for random value generation system. Allows generation
 * of random values with dynamic generators addition.
 * &lt;p&gt;
 * Registers generators declared in
 * {@code /META-INF/services/dev.orne.test.rnd.Generator}
 * SPI files in the class path.
 * &lt;p&gt;
 * Further registered generator adjustment can be performed with
 * {@link #getRegisteredGenerators()}, {@link #getGenerator(Class)},
 * {@link #register(Generator...)}, {@link #register(Collection)},
 * {@link #remove(Generator...)}, {@link #remove(Collection)}
 * and {@link #reset()}.
 * 
 * @author &lt;a href=&quot;mailto:wamphiry@orne.dev&quot;&gt;(w) Iker Hernaez&lt;/a&gt;
 * @version 1.1, 2023-11
 * @since 0.1
 */
@API(status=Status.STABLE, since=&quot;0.1&quot;)
public final class Generators {

    /**
     * The generator comparator by priority.
     */
<span class="fc" id="L78">    public static final Comparator&lt;Generator&gt; COMPARATOR =</span>
<span class="fc" id="L79">            Comparator.comparingInt(Generator::getPriority).reversed();</span>
    /** The by class generator cache. */
<span class="fc" id="L81">    private static final Map&lt;Class&lt;?&gt;, Generator&gt; CACHE = new WeakHashMap&lt;&gt;();</span>
    /** The registered generators. */
    private static List&lt;Generator&gt; registeredGenerators;

    /**
     * Private constructor.
     */
    private Generators() {
        // Utility class
    }

    /**
     * Checks if values of the specified type can be generated by any
     * registered generator.
     * 
     * @param type The type to check.
     * @return If values of the specified type can be generated.
     */
    public static boolean supports(
            final @NotNull Class&lt;?&gt; type) {
<span class="fc bfc" id="L101" title="All 2 branches covered.">        return getGenerator(type) != null;</span>
    }

    /**
     * Returns the default value for the specified type.
     * 
     * @param &lt;T&gt; The requested value type.
     * @param type The requested value type.
     * @return The default value for the specified type.
     * @throws GeneratorNotFoundException If no generator supports the
     * requested value type.
     */
    public static &lt;T&gt; T defaultValue(
            final @NotNull Class&lt;T&gt; type) {
<span class="fc" id="L115">        final Generator generator = getGeneratorInt(type);</span>
<span class="fc" id="L116">        return generator.defaultValue(type);</span>
    }

    /**
     * Returns the default value for the specified type.
     * 
     * @param &lt;T&gt; The requested value type.
     * @param type The requested value type.
     * @param params The generation parameter sources.
     * @return The default value for the specified type.
     * @throws GeneratorNotFoundException If no generator supports the
     * requested value type.
     * @throws GeneratorNotParameterizableException If the generator registered
     * for the requested value type is not parameterizable.
     */
    @API(status=Status.EXPERIMENTAL, since = &quot;0.1&quot;)
    public static &lt;T&gt; T defaultValue(
            final @NotNull Class&lt;T&gt; type,
            final @NotNull Object... params) {
<span class="fc" id="L135">        return requireParameterizableGenerator(type).defaultValue(type, params);</span>
    }

    /**
     * Returns the default value for the specified type allowing {@code null}
     * values.
     * &lt;p&gt;
     * This method should return {@code null} except for native types.
     * 
     * @param &lt;T&gt; The requested value type.
     * @param type The requested value type.
     * @return The nullable default value for the specified type.
     * @throws GeneratorNotFoundException If no generator supports the
     * requested value type.
     */
    public static &lt;T&gt; T nullableDefaultValue(
            final @NotNull Class&lt;T&gt; type) {
<span class="fc" id="L152">        final Generator generator = getGeneratorInt(type);</span>
<span class="fc" id="L153">        return generator.nullableDefaultValue(type);</span>
    }

    /**
     * Returns the default value for the specified type allowing {@code null}
     * values.
     * &lt;p&gt;
     * This method should return {@code null} except for native types.
     * 
     * @param &lt;T&gt; The requested value type.
     * @param type The requested value type.
     * @param params The generation parameter sources.
     * @return The nullable default value for the specified type.
     * @throws GeneratorNotFoundException If no generator supports the
     * requested value type.
     * @throws GeneratorNotParameterizableException If the generator registered
     * for the requested value type is not parameterizable.
     */
    @API(status=Status.EXPERIMENTAL, since = &quot;0.1&quot;)
    public static &lt;T&gt; T nullableDefaultValue(
            final @NotNull Class&lt;T&gt; type,
            final @NotNull Object... params) {
<span class="fc" id="L175">        return requireParameterizableGenerator(type).nullableDefaultValue(type, params);</span>
    }

    /**
     * Returns a random value of the specified type.
     * 
     * @param &lt;T&gt; The requested value type.
     * @param type The requested value type.
     * @return A random value for the specified type.
     * @throws GeneratorNotFoundException If no generator supports the
     * requested value type.
     */
    public static &lt;T&gt; T randomValue(
            final @NotNull Class&lt;T&gt; type) {
<span class="fc" id="L189">        final Generator generator = getGeneratorInt(type);</span>
<span class="fc" id="L190">        return generator.randomValue(type);</span>
    }

    /**
     * Returns a random value of the specified type.
     * 
     * @param &lt;T&gt; The requested value type.
     * @param type The requested value type.
     * @param params The generation parameter sources.
     * @return A random value for the specified type.
     * @throws GeneratorNotFoundException If no generator supports the
     * requested value type.
     * @throws GeneratorNotParameterizableException If the generator registered
     * for the requested value type is not parameterizable.
     */
    @API(status=Status.EXPERIMENTAL, since = &quot;0.1&quot;)
    public static &lt;T&gt; T randomValue(
            final @NotNull Class&lt;T&gt; type,
            final @NotNull Object... params) {
<span class="fc" id="L209">        return requireParameterizableGenerator(type).randomValue(type, params);</span>
    }

    /**
     * Returns a random value of the specified type allowing {@code null}
     * values.
     * &lt;p&gt;
     * The returned value has a probability of be {@code null} except for
     * native types. If not {@code null} behaves as {@code randomValue()}.
     * 
     * @param &lt;T&gt; The requested value type.
     * @param type The requested value type.
     * @return A random nullable value for the specified type.
     * @throws GeneratorNotFoundException If no generator supports the
     * requested value type.
     * @see #randomValue(Class)
     */
    public static &lt;T&gt; T nullableRandomValue(
            final @NotNull Class&lt;T&gt; type) {
<span class="fc" id="L228">        final Generator generator = getGeneratorInt(type);</span>
<span class="fc" id="L229">        return generator.nullableRandomValue(type);</span>
    }

    /**
     * Returns a random value of the specified type allowing {@code null}
     * values.
     * &lt;p&gt;
     * The returned value has a probability of be {@code null} except for
     * native types. If not {@code null} behaves as {@code randomValue()}.
     * 
     * @param &lt;T&gt; The requested value type.
     * @param type The requested value type.
     * @param params The generation parameter sources.
     * @return A random nullable value for the specified type.
     * @throws GeneratorNotFoundException If no generator supports the
     * requested value type.
     * @throws GeneratorNotParameterizableException If the generator registered
     * for the requested value type is not parameterizable.
     * @see #randomValue(Class)
     */
    @API(status=Status.EXPERIMENTAL, since = &quot;0.1&quot;)
    public static &lt;T&gt; T nullableRandomValue(
            final @NotNull Class&lt;T&gt; type,
            final @NotNull Object... params) {
<span class="fc" id="L253">        return requireParameterizableGenerator(type).nullableRandomValue(type, params);</span>
    }

    /**
     * Returns the generator to use for the specified value type.
     * 
     * @param type The value type to generate
     * @return The generator to use. Returns {@code null} is no one is
     * suitable.
     */
    public static Generator getGenerator(
            final @NotNull Class&lt;?&gt; type) {
<span class="fc" id="L265">        Validate.notNull(type);</span>
<span class="fc" id="L266">        final Generator result = getGeneratorInt(type);</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        return result == MissingGenerator.INSTANCE ? null : result;</span>
    }

    /**
     * Returns the parameterizable generator to use for the specified value
     * type. If no generator supports the requested value type or the
     * generator is not parameterizable returns {@code null}.
     * 
     * @param type The value type to generate
     * @return The generator to use. Returns {@code null} is no one is
     * suitable.
     */
    public static ParameterizableGenerator getParameterizableGenerator(
            final @NotNull Class&lt;?&gt; type) {
<span class="fc" id="L281">        final Generator result = getGenerator(type);</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (result instanceof ParameterizableGenerator) {</span>
<span class="fc" id="L283">            return (ParameterizableGenerator) result;</span>
        } else {
<span class="fc" id="L285">            return null;</span>
        }
    }

    /**
     * Returns the generator to use for the specified value type.
     * 
     * @param type The value type to generate
     * @return The generator to use. Returns {@code MissingGenerator.INSTANCE}
     * if no one is suitable.
     */
    static @NotNull Generator getGeneratorInt(
            final @NotNull Class&lt;?&gt; type) {
<span class="fc" id="L298">        return CACHE.computeIfAbsent(type, Generators::findGenerator);</span>
    }

    /**
     * Return the parameterizable generator for the specified value type.
     * 
     * @param type The value type to generate
     * @return The generator to use.
     * @throws GeneratorNotFoundException If no generator supports the
     * requested value type.
     * @throws GeneratorNotParameterizableException If the registered generator
     * is not parameterizable.
     */
    static @NotNull ParameterizableGenerator requireParameterizableGenerator(
            final @NotNull Class&lt;?&gt; type) {
<span class="fc" id="L313">        final Generator generator = getGeneratorInt(type);</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (generator == MissingGenerator.INSTANCE) {</span>
<span class="fc" id="L315">            throw new GeneratorNotFoundException(MissingGenerator.ERR_MSG);</span>
        } else {
<span class="fc" id="L317">            return generator.asParameterizable();</span>
        }
    }

    /**
     * Finds the generator to use for the specified value type.
     * 
     * @param type The value type to generate
     * @return The generator to use. Returns {@code MissingGenerator.INSTANCE}
     * if no one is suitable.
     */
    static @NotNull Generator findGenerator(
            final @NotNull Class&lt;?&gt; type) {
<span class="fc" id="L330">        Generator result = MissingGenerator.INSTANCE;</span>
<span class="fc" id="L331">        synchronized (Generators.class) {</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">            for (final Generator generator : getGeneratorsInt()) {</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">                if (generator.supports(type)) {</span>
<span class="fc" id="L334">                    result = generator;</span>
<span class="fc" id="L335">                    break;</span>
                }
<span class="fc" id="L337">            }</span>
<span class="fc" id="L338">        }</span>
<span class="fc" id="L339">        return result;</span>
    }

    /**
     * Returns a targeted generator for the specified field.
     * &lt;p&gt;
     * If a parameterizable generator has been registered for the specified type
     * extracts the generation parameters from the field declaration.
     * 
     * @param &lt;T&gt; The type of the generated values
     * @param field The bean field
     * @return A generator for the type of the specified field
     * @since 0.2
     */
    @API(status=Status.EXPERIMENTAL, since = &quot;0.2&quot;)
    public static &lt;T&gt; @NotNull PropertyTypeGenerator&lt;T&gt; forField(
            final @NotNull Field field) {
<span class="fc" id="L356">        return PropertyTypeGenerator.&lt;T&gt;targeting(field);</span>
    }

    /**
     * Returns a targeted generator for the specified field.
     * &lt;p&gt;
     * If a parameterizable generator has been registered for the specified type
     * extracts the generation parameters from the field declaration.
     * 
     * @param &lt;T&gt; The type of the generated values
     * @param beanType The bean type
     * @param field The bean field
     * @return A generator for the type of the specified field
     * @since 0.2
     */
    @API(status=Status.EXPERIMENTAL, since = &quot;0.2&quot;)
    public static &lt;T&gt; @NotNull PropertyTypeGenerator&lt;T&gt; forField(
            final @NotNull Class&lt;?&gt; beanType,
            final @NotNull Field field) {
<span class="fc" id="L375">        return PropertyTypeGenerator.&lt;T&gt;targeting(beanType, field);</span>
    }

    /**
     * Returns a targeted generator for the specified bean property.
     * &lt;p&gt;
     * If a parameterizable generator has been registered for the specified type
     * extracts the generation parameters from the property declaration.
     * 
     * @param &lt;T&gt; The type of the generated values
     * @param beanType The bean type
     * @param property The property of the bean
     * @return A generator for the type of the specified property
     */
    @API(status=Status.EXPERIMENTAL, since = &quot;0.1&quot;)
    public static &lt;T&gt; @NotNull PropertyTypeGenerator&lt;T&gt; forProperty(
            final @NotNull Class&lt;?&gt; beanType,
            final @NotNull String property) {
<span class="fc" id="L393">        return PropertyTypeGenerator.&lt;T&gt;targeting(beanType, property);</span>
    }

    /**
     * Returns a targeted generator for the specified parameter.
     * &lt;p&gt;
     * If a parameterizable generator has been registered for the specified type
     * extracts the generation parameters from the parameter declaration.
     * 
     * @param &lt;T&gt; The type of the generated values
     * @param parameter The parameter
     * @return A generator for the type of the specified parameter
     * @since 0.2
     */
    @API(status=Status.EXPERIMENTAL, since = &quot;0.2&quot;)
    public static &lt;T&gt; @NotNull ParameterTypeGenerator&lt;T&gt; forParameter(
            final @NotNull Parameter parameter) {
<span class="fc" id="L410">        return ParameterTypeGenerator.&lt;T&gt;targeting(parameter);</span>
    }

    /**
     * Returns a targeted generator for the specified method parameter.
     * &lt;p&gt;
     * If a parameterizable generator has been registered for the specified type
     * extracts the generation parameters from the method declaration.
     * 
     * @param &lt;T&gt; The type of the generated values
     * @param method The method
     * @param parameterIndex The parameter index
     * @return A generator for the type of the specified method parameter
     */
    @API(status=Status.EXPERIMENTAL, since = &quot;0.1&quot;)
    public static &lt;T&gt; @NotNull MethodParameterTypeGenerator&lt;T&gt; forParameter(
            final @NotNull Method method,
            final @NotNull int parameterIndex) {
<span class="fc" id="L428">        return MethodParameterTypeGenerator.&lt;T&gt;targeting(method, parameterIndex);</span>
    }

    /**
     * Returns a targeted generator for the specified method parameter.
     * &lt;p&gt;
     * If a parameterizable generator has been registered for the specified type
     * extracts the generation parameters from the method declaration.
     * 
     * @param &lt;T&gt; The type of the generated values
     * @param cls The method's class
     * @param method The method name
     * @param parameterTypes The method parameter types
     * @param parameterIndex The parameter index
     * @return A generator for the type of the specified method parameter
     */
    @API(status=Status.EXPERIMENTAL, since = &quot;0.1&quot;)
    public static &lt;T&gt; @NotNull MethodParameterTypeGenerator&lt;T&gt; forParameter(
            final @NotNull Class&lt;?&gt; cls,
            final @NotNull String method,
            final @NotNull Class&lt;?&gt;[] parameterTypes,
            final @NotNull int parameterIndex) {
<span class="fc" id="L450">        return MethodParameterTypeGenerator.&lt;T&gt;targeting(cls, method, parameterIndex, parameterTypes);</span>
    }

    /**
     * Returns a targeted generator for the specified method return type.
     * &lt;p&gt;
     * If a parameterizable generator has been registered for the specified type
     * extracts the generation parameters from the method declaration.
     * 
     * @param &lt;T&gt; The type of the generated values
     * @param method The method
     * @return A generator for the type of the specified method return type
     */
    @API(status=Status.EXPERIMENTAL, since = &quot;0.1&quot;)
    public static &lt;T&gt; @NotNull MethodReturnTypeGenerator&lt;T&gt; forReturnType(
            final @NotNull Method method) {
<span class="fc" id="L466">        return MethodReturnTypeGenerator.&lt;T&gt;targeting(method);</span>
    }

    /**
     * Returns a targeted generator for the specified method return type.
     * &lt;p&gt;
     * If a parameterizable generator has been registered for the specified type
     * extracts the generation parameters from the method declaration.
     * 
     * @param &lt;T&gt; The type of the generated values
     * @param cls The method's class
     * @param parameterTypes The method parameter types
     * @param method The method name
     * @return A generator for the type of the specified method return type
     */
    @API(status=Status.EXPERIMENTAL, since = &quot;0.1&quot;)
    public static &lt;T&gt; @NotNull MethodReturnTypeGenerator&lt;T&gt; forReturnType(
            final @NotNull Class&lt;?&gt; cls,
            final @NotNull String method,
            final @NotNull Class&lt;?&gt;[] parameterTypes) {
<span class="fc" id="L486">        return MethodReturnTypeGenerator.&lt;T&gt;targeting(cls, method, parameterTypes);</span>
    }

    /**
     * Returns a targeted generator for the specified constructor parameter.
     * &lt;p&gt;
     * If a parameterizable generator has been registered for the specified type
     * extracts the generation parameters from the constructor declaration.
     * 
     * @param &lt;T&gt; The type of the generated values
     * @param constructor The constructor
     * @param parameterIndex The parameter index
     * @return A generator for the type of the specified constructor parameter
     */
    @API(status=Status.EXPERIMENTAL, since = &quot;0.1&quot;)
    public static &lt;T&gt; @NotNull ConstructorParameterTypeGenerator&lt;T&gt; forParameter(
            final @NotNull Constructor&lt;?&gt; constructor,
            final @NotNull int parameterIndex) {
<span class="fc" id="L504">        return ConstructorParameterTypeGenerator.&lt;T&gt;targeting(constructor, parameterIndex);</span>
    }

    /**
     * Returns a targeted generator for the specified constructor parameter.
     * &lt;p&gt;
     * If a parameterizable generator has been registered for the specified type
     * extracts the generation parameters from the constructor declaration.
     * 
     * @param &lt;T&gt; The type of the generated values
     * @param cls The class of the constructor
     * @param parameterTypes The constructor parameter types
     * @param parameterIndex The parameter index
     * @return A generator for the type of the specified constructor parameter
     */
    @API(status=Status.EXPERIMENTAL, since = &quot;0.1&quot;)
    public static &lt;T&gt; @NotNull ConstructorParameterTypeGenerator&lt;T&gt; forParameter(
            final @NotNull Class&lt;?&gt; cls,
            final @NotNull Class&lt;?&gt;[] parameterTypes,
            final @NotNull int parameterIndex) {
<span class="fc" id="L524">        return ConstructorParameterTypeGenerator.&lt;T&gt;targeting(cls, parameterIndex, parameterTypes);</span>
    }

    /**
     * Returns an unmodifiable list with the registered generators.
     * 
     * @return The registered generators
     */
    public static @NotNull List&lt;Generator&gt; getRegisteredGenerators() {
<span class="fc" id="L533">        return Collections.unmodifiableList(getGeneratorsInt());</span>
    }

    /**
     * Adds the specified generators to the registered generators.
     * 
     * @param generators The generators to register
     */
    public static void register(
            final @NotNull Generator... generators) {
<span class="fc" id="L543">        Validate.notNull(generators);</span>
<span class="fc" id="L544">        register(Arrays.asList(generators));</span>
<span class="fc" id="L545">    }</span>

    /**
     * Adds the specified generators to the registered generators.
     * 
     * @param generators The generators to register
     */
    public static void register(
            final @NotNull Collection&lt;Generator&gt; generators) {
<span class="fc" id="L554">        Validate.notNull(generators);</span>
<span class="fc" id="L555">        Validate.noNullElements(generators);</span>
<span class="fc" id="L556">        synchronized (Generators.class) {</span>
<span class="fc" id="L557">            final List&lt;Generator&gt; intList = getGeneratorsInt();</span>
<span class="fc" id="L558">            intList.addAll(generators);</span>
<span class="fc" id="L559">            Collections.sort(intList, COMPARATOR);</span>
<span class="fc" id="L560">            CACHE.clear();</span>
<span class="fc" id="L561">        }</span>
<span class="fc" id="L562">    }</span>

    /**
     * Removes the specified generators from the registered generators.
     * 
     * @param generators The generators to remove
     */
    public static void remove(
            final @NotNull Generator... generators) {
<span class="fc" id="L571">        Validate.notNull(generators);</span>
<span class="fc" id="L572">        remove(Arrays.asList(generators));</span>
<span class="fc" id="L573">    }</span>

    /**
     * Removes the specified generators from the registered generators.
     * 
     * @param generators The generators to remove
     */
    public static void remove(
            final @NotNull Collection&lt;Generator&gt; generators) {
<span class="fc" id="L582">        Validate.notNull(generators);</span>
<span class="fc" id="L583">        Validate.noNullElements(generators);</span>
<span class="fc" id="L584">        synchronized (Generators.class) {</span>
<span class="fc" id="L585">            final List&lt;Generator&gt; intList = getGeneratorsInt();</span>
<span class="fc" id="L586">            intList.removeAll(generators);</span>
<span class="fc" id="L587">            Collections.sort(intList, COMPARATOR);</span>
<span class="fc" id="L588">            CACHE.clear();</span>
<span class="fc" id="L589">        }</span>
<span class="fc" id="L590">    }</span>

    /**
     * Resets the loaded and cached generators. Next call will regenerate the
     * generator list (including SPI generators) and restart generator caching.
     */
    public static void reset() {
<span class="fc" id="L597">        synchronized (Generators.class) {</span>
<span class="fc" id="L598">            registeredGenerators = null;</span>
<span class="fc" id="L599">            CACHE.clear();</span>
<span class="fc" id="L600">        }</span>
<span class="fc" id="L601">    }</span>

    /**
     * Returns a modifiable list with the registered generators.
     * If generators has not been loaded loads the default generators,
     * including generators registered through SPI.
     * 
     * @return The registered generators
     */
    static @NotNull List&lt;Generator&gt; getGeneratorsInt() {
<span class="fc" id="L611">        synchronized (Generators.class) {</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">            if (registeredGenerators == null) {</span>
<span class="fc" id="L613">                registeredGenerators = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L614">                registeredGenerators.addAll(loadSpiGenerators());</span>
<span class="fc" id="L615">                Collections.sort(registeredGenerators, COMPARATOR);</span>
            }
<span class="fc" id="L617">            return registeredGenerators;</span>
        }
    }

    /**
     * Returns the internal by class generator cache.
     * 
     * @return The internal by class generator cache
     */
    static @NotNull Map&lt;Class&lt;?&gt;, Generator&gt; getCacheInt() {
<span class="fc" id="L627">        return CACHE;</span>
    }

    /**
     * Loads the value generators declared through SPI for interface
     * {@code dev.orne.test.rnd.Generator}
     * 
     * @return The SPI declared generators
     * @see ServiceLoader
     */
    static @NotNull List&lt;Generator&gt; loadSpiGenerators() {
<span class="fc" id="L638">        final List&lt;Generator&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L639">        final ServiceLoader&lt;Generator&gt; loader =</span>
<span class="fc" id="L640">                ServiceLoader.load(Generator.class);</span>
<span class="fc" id="L641">        final Iterator&lt;Generator&gt; it = loader.iterator();</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">        while (it.hasNext()) {</span>
<span class="fc" id="L643">            final Generator generator = it.next();</span>
<span class="fc" id="L644">            result.add(generator);</span>
<span class="fc" id="L645">        }</span>
<span class="fc" id="L646">        return result;</span>
    }

    /**
     * Cache value for missing generators for a value type.
     * 
     * @author &lt;a href=&quot;mailto:wamphiry@orne.dev&quot;&gt;(w) Iker Hernaez&lt;/a&gt;
     * @version 1.0, 2022-10
     * @since Generators 1.0
     */
    @API(status=Status.INTERNAL, since=&quot;0.1&quot;)
    public static final class MissingGenerator
    implements Generator {

        /** The error message. */
        public static final String ERR_MSG = &quot;No suitable generator found&quot;;
        /** The generator placeholder for missing generators. */
<span class="fc" id="L663">        public static final MissingGenerator INSTANCE = new MissingGenerator();</span>

        /**
         * Private constructor.
         */
        private MissingGenerator() {
            super();
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public boolean supports(
                final @NotNull Class&lt;?&gt; type) {
<span class="fc" id="L678">            return false;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public &lt;T&gt; @NotNull T defaultValue(
                final @NotNull Class&lt;T&gt; type) {
<span class="fc" id="L687">            throw new GeneratorNotFoundException(ERR_MSG);</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public &lt;T&gt; T nullableDefaultValue(
                final @NotNull Class&lt;T&gt; type) {
<span class="fc" id="L696">            throw new GeneratorNotFoundException(ERR_MSG);</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public &lt;T&gt; @NotNull T randomValue(
                final @NotNull Class&lt;T&gt; type) {
<span class="fc" id="L705">            throw new GeneratorNotFoundException(ERR_MSG);</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public &lt;T&gt; T nullableRandomValue(
                final @NotNull Class&lt;T&gt; type) {
<span class="fc" id="L714">            throw new GeneratorNotFoundException(ERR_MSG);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>