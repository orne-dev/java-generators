package dev.orne.test.rnd;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

/*-
 * #%L
 * Orne Test Generators
 * %%
 * Copyright (C) 2021 Orne Developments
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Lesser Public License for more details.
 * 
 * You should have received a copy of the GNU General Lesser Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/lgpl-3.0.html>.
 * #L%
 */

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.ServiceLoader;
import java.util.WeakHashMap;

import javax.validation.constraints.NotNull;

import org.apache.commons.lang3.Validate;
import org.apiguardian.api.API;
import org.apiguardian.api.API.Status;

/**
 * Main entry point for random value generation system. Allows generation
 * of random values with dynamic generators addition.
 * <p>
 * Registers generators declared in
 * {@code /META-INF/services/dev.orne.test.rnd.Generator}
 * SPI files in the class path.
 * <p>
 * Further registered generator adjustment can be performed with
 * {@link #getRegisteredGenerators()}, {@link #getGenerator(Class)},
 * {@link #register(Generator...)}, {@link #register(Collection)},
 * {@link #remove(Generator...)}, {@link #remove(Collection)}
 * and {@link #reset()}.
 * 
 * @author <a href="mailto:wamphiry@orne.dev">(w) Iker Hernaez</a>
 * @version 1.0, 2022-10
 * @since 0.1
 */
@API(status=Status.STABLE, since="0.1")
public final class Generators {

    /** The by class generator cache. */
    private static final Map<Class<?>, Generator> CACHE = new WeakHashMap<>();
    /** The registered generators. */
    private static List<Generator> registeredGenerators;

    /**
     * Private constructor.
     */
    private Generators() {
        // Utility class
    }

    /**
     * Checks if values of the specified type can be generated by any
     * registered generator.
     * 
     * @param type The type to check.
     * @return If values of the specified type can be generated.
     */
    public static boolean supports(
            final @NotNull Class<?> type) {
        return getGenerator(type) != null;
    }

    /**
     * Returns the default value for the specified type.
     * 
     * @param <T> The requested value type.
     * @param type The requested value type.
     * @return The default value for the specified type.
     * @throws GeneratorNotFoundException If no generator is supports the
     * requested value type.
     */
    public static <T> T defaultValue(
            final @NotNull Class<T> clazz) {
        final Generator generator = getGeneratorInt(clazz);
        return generator.defaultValue(clazz);
    }

    /**
     * Returns the default value for the specified type allowing {@code null}
     * values.
     * <p>
     * This method should return {@code null} except for native types.
     * 
     * @param <T> The requested value type.
     * @param type The requested value type.
     * @return The nullable default value for the specified type.
     * @throws GeneratorNotFoundException If no generator is supports the
     * requested value type.
     */
    public static <T> T nullableDefaultValue(
            final @NotNull Class<T> clazz) {
        final Generator generator = getGeneratorInt(clazz);
        return generator.nullableDefaultValue(clazz);
    }

    /**
     * Returns a random value of the specified type.
     * 
     * @param <T> The requested value type.
     * @param type The requested value type.
     * @return A random value for the specified type.
     * @throws GeneratorNotFoundException If no generator is supports the
     * requested value type.
     */
    public static <T> T randomValue(
            final @NotNull Class<T> clazz) {
        final Generator generator = getGeneratorInt(clazz);
        return generator.randomValue(clazz);
    }

    /**
     * Returns a random value of the specified type allowing {@code null}
     * values.
     * <p>
     * The returned value has a probability of be {@code null} except for
     * native types. If not {@code null} behaves as {@code randomValue()}.
     * 
     * @param <T> The requested value type.
     * @param type The requested value type.
     * @return A random nullable value for the specified type.
     * @throws GeneratorNotFoundException If no generator is supports the
     * requested value type.
     * @see #randomValue(Class)
     */
    public static <T> T nullableRandomValue(
            final @NotNull Class<T> clazz) {
        final Generator generator = getGeneratorInt(clazz);
        return generator.nullableRandomValue(clazz);
    }

    /**
     * Returns the generator to use for the specified value type.
     * 
     * @param type The value type to generate
     * @return The generator to use. Returns {@code null} is no one is
     * suitable.
     */
    public static Generator getGenerator(
            final @NotNull Class<?> type) {
        final Generator result = getGeneratorInt(type);
        return result == MissingGenerator.INSTANCE ? null : result;
    }

    /**
     * Returns the generator to use for the specified value type.
     * 
     * @param type The value type to generate
     * @return The generator to use. Returns {@code MissingGenerator.INSTANCE}
     * if no one is suitable.
     */
    static @NotNull Generator getGeneratorInt(
            final @NotNull Class<?> type) {
        return CACHE.computeIfAbsent(type, Generators::findGenerator);
    }

    /**
     * Finds the generator to use for the specified value type.
     * 
     * @param type The value type to generate
     * @return The generator to use. Returns {@code MissingGenerator.INSTANCE}
     * if no one is suitable.
     */
    static @NotNull Generator findGenerator(
            final @NotNull Class<?> type) {
        Generator result = MissingGenerator.INSTANCE;
        synchronized (Generators.class) {
            for (final Generator generator : getGeneratorsInt()) {
                if (generator.supports(type)) {
                    result = generator;
                    break;
                }
            }
        }
        return result;
    }

    /**
     * Returns an unmodifiable list with the registered generators.
     * 
     * @return The registered generators
     */
    public static @NotNull List<Generator> getRegisteredGenerators() {
        return Collections.unmodifiableList(getGeneratorsInt());
    }

    /**
     * Adds the specified generator at the end of the registered generators.
     * 
     * @param generators The generators to register
     */
    public static void register(
            final @NotNull Generator... generators) {
        Validate.notNull(generators);
        register(Arrays.asList(generators));
    }

    /**
     * Adds the specified generator at the end of the registered generators.
     * 
     * @param generator The value generator to register
     */
    public static void register(
            final @NotNull Collection<Generator> generators) {
        Validate.notNull(generators);
        Validate.noNullElements(generators);
        synchronized (Generators.class) {
            final List<Generator> intList = getGeneratorsInt();
            intList.addAll(generators);
            Collections.sort(intList, Priority.COMPARATOR);
            CACHE.clear();
        }
    }

    /**
     * Removes the specified generator from the registered generators.
     * 
     * @param generators The generators to remove
     */
    public static void remove(
            final @NotNull Generator... generators) {
        Validate.notNull(generators);
        remove(Arrays.asList(generators));
    }

    /**
     * Removes the specified generator from the registered generators.
     * 
     * @param generators The generators to remove
     */
    public static void remove(
            final @NotNull Collection<Generator> generators) {
        Validate.notNull(generators);
        Validate.noNullElements(generators);
        synchronized (Generators.class) {
            final List<Generator> intList = getGeneratorsInt();
            intList.removeAll(generators);
            Collections.sort(intList, Priority.COMPARATOR);
            CACHE.clear();
        }
    }

    /**
     * Resets the loaded and cached generators. Next call will regenerate the
     * generator list (including SPI generators) and restart generator caching.
     */
    public static void reset() {
        synchronized (Generators.class) {
            registeredGenerators = null;
            CACHE.clear();
        }
    }

    /**
     * Returns a modifiable list with the registered generators.
     * If generators has not been loaded loads the default generators,
     * including generators registered through SPI.
     * 
     * @return The registered generators
     */
    static @NotNull List<Generator> getGeneratorsInt() {
        synchronized (Generators.class) {
            if (registeredGenerators == null) {
                registeredGenerators = new ArrayList<>();
                registeredGenerators.addAll(loadSpiGenerators());
                Collections.sort(registeredGenerators, Priority.COMPARATOR);
            }
            return registeredGenerators;
        }
    }

    /**
     * Returns the internal by class generator cache.
     * 
     * @return The internal by class generator cache
     */
    public static @NotNull Map<Class<?>, Generator> getCacheInt() {
        return CACHE;
    }

    /**
     * Loads the value generators declared through SPI for interface
     * {@code dev.orne.test.rnd.Generator}
     * 
     * @return The SPI declared generators
     * @see ServiceLoader
     */
    static @NotNull List<Generator> loadSpiGenerators() {
        final List<Generator> result = new ArrayList<>();
        final ServiceLoader<Generator> loader =
                ServiceLoader.load(Generator.class);
        final Iterator<Generator> it = loader.iterator();
        while (it.hasNext()) {
            final Generator generator = it.next();
            result.add(generator);
        }
        return result;
    }

    /**
     * 
     * @author <a href="mailto:wamphiry@orne.dev">(w) Iker Hernaez</a>
     * @version 1.0, 2022-10
     * @since Generators 1.0
     */
    @API(status=Status.INTERNAL, since="0.1")
    public static final class MissingGenerator
    implements Generator {

        /** The error message. */
        public static final String ERR_MSG = "No suitable generator found";
        /** The generator placeholder for missing generators. */
        public static final MissingGenerator INSTANCE = new MissingGenerator();

        /**
         * Private constructor.
         */
        private MissingGenerator() {
            super();
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public boolean supports(
                final @NotNull Class<?> type) {
            return false;
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public <T> @NotNull T defaultValue(
                final @NotNull Class<T> type) {
            throw new GeneratorNotFoundException(ERR_MSG);
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public <T> T nullableDefaultValue(
                final @NotNull Class<T> type) {
            throw new GeneratorNotFoundException(ERR_MSG);
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public <T> @NotNull T randomValue(
                final @NotNull Class<T> type) {
            throw new GeneratorNotFoundException(ERR_MSG);
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public <T> T nullableRandomValue(
                final @NotNull Class<T> type) {
            throw new GeneratorNotFoundException(ERR_MSG);
        }
    }
}
